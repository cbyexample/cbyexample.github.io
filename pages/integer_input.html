<h1 id="reading-integer-input">Reading integer input</h1>
<p>Reading integers from an input stream is something which is very easy to get wrong. There are a handful of things that can go wrong, and in order to write C that is resilient against all of them, one must take some care.</p>
<p>The two things which most commonly cause problems:</p>
<pre><code>- The input does not resemble an integer (e.g., &#39;abc&#39; when you are expecting a decimal integer).

- The integer cannot be represented by the type of the object you&#39;re trying to store it in.</code></pre>
<p>A common approach is to use <code>scanf</code>. There are two flaws in this approach:</p>
<pre><code>- `scanf` does not check protect against integer overflow

- `scanf` is not very appropriate when you want control over how whitespace is consumed.</code></pre>
<p>The most most robust way to read and parse integers using the standard library is to first read the integer in the format you like using functions from <code>stdio.h</code>, such as <code>getchar</code>, or <code>fgets</code>, and then use one of:</p>
<pre><code>- `strtol`

- `strtoll`

- `strtoul`

- `strtoull`

- `strtoimax`

- `strtoumax`</code></pre>
<p>to parse the the input as an integer. Which of these functions you should use depends of course on the type that you're using.</p>
<p>Here is a small program demonstrating a reasonable way to read and parse an integer from <code>stdin</code>:</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;errno.h&gt;

int main(void)
{
    char buffer[100];
    
    if (!fgets(buffer, 100, stdin))
        return 1;

    char *end;
    errno = 0;
    long value = strtol(buffer, &amp;end, 10);

    if ((*end &amp;&amp; *end != &#39;\n&#39;) || end == buffer)
        return 1;

    if (errno)
        return 2;

    return 0;
}</code></pre>
